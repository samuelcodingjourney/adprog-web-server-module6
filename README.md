## Module 6
### Commit 1 Reflection notes
The code inside handle_connection method firstly have a parameter of mut stream: TcpStream which is to take TcpStream that is named stream and the mut keyword tells that the stream can be modified in the function. The first line which is let buf_reader = BufReader::new(&mut stream) would create a buffer reader to read bytes from the stream or from the TcpStream. The let http_request: Vec<_> = buf_reader.lines() would return an iterator thanks to the lines() method and that those would be read from buf_reader later stored to http_request. The .map would unwrap the result returned after .lines(), the .take_while collect lines until an empty line is encountered, and also the .collect() is used to collecet those lines into the vector. The types of vector elements are infered by Rust when notation of Vec<_> was used. Finally, the println is used at the end to print to the console of the collected result of the HTTP request that is in the vector containing the lines of the HTTP request from TCP stream.

### Commit 2 Reflection notes
The changed version of handle_connection adds status_lilne variable to represent HTTP status line. It also has let contents = fs::read_to_string("hello.html").unwrap(); that reads the html file of hello.html and turn it to a string. The let length = contents.len() would then calculate the length of that contents string. The formatting for the response would be used to format the HTTP response that includes the status line, content length header, and also the contents of the file itself. The response would then be written to the TCP stream by converting the response string to bytes using as_bytes() and write them to the stream as in the line of stream.write_all(response.as_bytes()).unwrap(). Basically the added things to the handle_connection function is to generate a HTTP response because of the reading of the file hello.html.

![Commit 2 screen capture](/assets/images/commit2.png) 